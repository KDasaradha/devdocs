
import React from 'react'; // Ensure React is imported
import ReactMarkdown, { type Components } from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeRaw from 'rehype-raw';

// Custom components
import { CodeBlock } from './code-block';
import { cn } from '@/lib/utils';

interface MarkdownRendererProps {
  markdownContent: string; // This prop receives the HTML string processed by lib/markdown.ts
}

// Custom components to override default HTML element rendering
const components: Components = {
  pre: ({ node, className, children, ...props }: any) => {
    // Logic to extract raw string for CodeBlock copy functionality
    let rawString = '';
    // This logic tries to extract text content from the first child of `pre`, which is usually `code`
    if (React.Children.count(children) === 1) {
      const child = React.Children.toArray(children)[0] as React.ReactElement;
      // Check if the child is a 'code' element and has string children
      if (child && child.type === 'code' && child.props && typeof child.props.children === 'string') {
        rawString = child.props.children.replace(/\n$/, '');
      } else if (child && child.props && Array.isArray(child.props.children)) {
         // Handle cases where children of <code> are arrays of strings/elements (like highlighted code)
          rawString = React.Children.toArray(child.props.children).map(c => {
             if (typeof c === 'string') return c;
             if (React.isValidElement(c) && typeof c.props.children === 'string') return c.props.children;
             return '';
          }).join('');
      }
    } else {
      // Fallback for unexpected structures: try to concatenate all string children
      rawString = React.Children.toArray(children).map(child => {
        if (typeof child === 'string') return child;
        if (React.isValidElement(child) && typeof child.props.children === 'string') return child.props.children;
        // Add more robust extraction if needed, e.g., recursively traversing deeper elements
        return '';
      }).join('');
    }
    // Remove trailing newline if present
    rawString = rawString.replace(/\n$/, '');

    // Pass the original className (e.g., language-js) and children (the <code> tag with highlighted spans)
    return (
      <CodeBlock rawString={rawString} className={className} {...props}>
        {children}
      </CodeBlock>
    );
  },
  code: ({ node, inline, className, children, ...props }: any) => {
    // For inline code, apply specific styling
    if (inline) {
      return <code className={cn("bg-muted/70 text-accent px-1.5 py-0.5 rounded text-sm font-mono", className)} {...props}>{children}</code>;
    }
    // For code blocks, className (like language-js) is passed to CodeBlock via the <pre> wrapper.
    // The direct <code> tag here will be inside CodeBlock's <pre>. Let CodeBlock handle the outer <pre>.
    // The rehype-prism-plus plugin usually adds the language class here too.
    return <code className={cn("font-mono", className)} {...props}>{children}</code>;
  },
  // Add group class to headings to enable hover effect on the anchor link
  // This assumes rehype-autolink-headings wraps the heading content in the <a>
  h1: ({ node, ...props }) => <h1 className="group" {...props} />,
  h2: ({ node, ...props }) => <h2 className="group" {...props} />,
  h3: ({ node, ...props }) => <h3 className="group" {...props} />,
  h4: ({ node, ...props }) => <h4 className="group" {...props} />,
  h5: ({ node, ...props }) => <h5 className="group" {...props} />,
  h6: ({ node, ...props }) => <h6 className="group" {...props} />,
  // Ensure links rendered from markdown don't get nested inside heading anchor links by rehype-autolink-headings
  // (This is usually handled by the plugin configuration `behavior: 'wrap'`, but doesn't hurt to be defensive)
  // We will customize the rendering of links within headings if needed
  a: ({ node, href, children, ...props }: any) => {
     // Check if the link is inside a heading (more reliable check needed if structure varies)
     // This is a simple check, might need refinement based on actual HAST structure
     const isInsideHeading = node?.position?.start?.line === node?.parent?.position?.start?.line;

    // If it's an anchor link generated by autolink-headings, render it as is
    if (props.className === 'anchor') {
        return <a href={href} {...props}>{children}</a>;
    }

    // Render normal links
    return <a href={href} {...props}>{children}</a>;
  },
};


export function MarkdownRenderer({ markdownContent }: MarkdownRendererProps) {
  if (!markdownContent) {
    return <div className="prose dark:prose-invert max-w-none"><p className="text-muted-foreground italic">(Content is empty)</p></div>;
  }

  return (
    <ReactMarkdown
      className="prose dark:prose-invert max-w-none"
      remarkPlugins={[remarkGfm]}
      // Use rehypeRaw to handle the HTML produced by the server-side processing
      rehypePlugins={[rehypeRaw]}
      components={components}
      // Pass the pre-processed HTML string as children
    >
      {markdownContent}
    </ReactMarkdown>
  );
}

      
    